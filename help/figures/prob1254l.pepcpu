// File: exer1207f.pepcpu
// Computer Systems, Fourth Edition
// Exercise 12.7(f)
// STBYTEA there,sxf
// RTL: byteOprnd <- A<8..15>
// Stack-indexed deferred addressing: Oprnd = Mem[Mem[SP + OprndSpec] + X]
// Shortest known implementation: 16 cycles

UnitPre: A=0x00AB, IR=0xF700F1, SP=0x000E, Mem[0x00FF]=0x01F9, X=0x000A
UnitPre: N=1, Z=0, V=1, C=0, T1=0x0A // T1 stores NZVC=1010 in von Neumann step
UnitPost: Mem[0x0203]=0xAB, N=1, Z=0, V=1, C=0

// T3 <- SP + OprndSpec
1. A=5, B=10, AMux=1, ALU=1, CMux=1, C=15; CCk, LoadCk
2. A=4, B=9, AMux=1, ALU=2, CMux=1, C=14; LoadCk

// T5<high> <- Mem[T3], T4 <- T3 + 1
3. A=14, B=15; MARCk
4. MemRead, A=15, B=23, AMux=1, ALU=1, CMux=1, C=17; CCk, LoadCk
5. MemRead, A=14, B=22, AMux=1, ALU=2, CMux=1, MDRMux=0, C=16; LoadCk, MDRCk
6. AMux=0, ALU=0, CMux=1, C=18; LoadCk

// T5<low> <- Mem[T4]
7. A=16, B=17; MARCk
8. MemRead
9. MemRead, MDRMux=0; MDRCk
10. AMux=0, ALU=0, CMux=1, C=19; LoadCk

// T6 <- T5 + X
11. A=3, B=19, AMux=1, ALU=1, CMux=1, C=21; CCk, LoadCk
12. A=2, B=18, AMux=1, ALU=2, CMux=1, C=20; LoadCk

// Mem[T6] <- A<low>, restore C in T1 from Fetch
13. A=20, B=21; MARCk
14. A=1, AMux=1, ALU=0, CMux=1, MDRMux=1; MDRCk
15. MemWrite
16. MemWrite, A=11, AMux=1, ALU=15; CCk
